# 전처리기

## 목차

[1. 전처리기](#전처리기)

[2. 매크로](#매크로)

[3. 매개 변수를 갖는 매크로](#매개-변수를-갖는-매크로)

[4. #연산자](#연산자)

[5. 헤더 파일](#헤더-파일)

[6. 디버깅 코드](#디버깅-코드)

## 전처리기

C 언어에서는 컴파일러에 특정 작업을 지시하는 전처리기를 제공합니다.  

보통 전처리기는 반복되는 값이나 작업을 미리 정의할 때 사용하며,  

컴파일 옵션 설정이나 조건부 컴파일도 가능합니다.  

#으로 시작하는 행을 전처리 지시자라고 하며,  

프로그램 개발과 유지보수를 쉽게, 가독성을 높이는 역할을 합니다.  

전처리기는  

- 컴파일러가 컴파일을 시작하기 전에 미리 처리해주는 것입니다.

- #으로 시작합니다.  

- 문장을 끝낼 때 세미콜론(;)을 붙이지 않습니다.  

- C언어의 나머지 부분과 독립적입니다.  

  

## 매크로

C언어에서 #define으로 매크로를 정의하는 법을 알아봅시다.  

예를 들어, 배열이나 동적 메모리를 할당한 포인터는 반복문과 함께 사용하는 경우가 많습니다.  

보통 배열, 메모리 크기만큼 반복하면서 값을 출력하거나 저장하기 때문입니다.  

**프로그램 9.1** 은 배열을 선언한 뒤, 문자를 저장하고 하나씩 출력하는 프로그램입니다.  

```c
#include <stdio.h>

int main(){

    char s1[10];   

    for (int i = 0; i < 10; i++){
        s1[i] = 97 + i;
    }

    for (int i = 0; i < 10; i++)   {
        printf("%c ", s1[i]);
    }

    return 0;
}
```

**실행 결과**

```
a b c d e f g h i j
```

1. 먼저 문자 10개 크기의 배열을 선언하고  

2. 두개의 반복문을 배열 크기만큼 반복했습니다.  



코드를 살펴보면 배열의 크기인 10이 계속해서 반복된다는 것을 알 수 있습니다.  

이런 짧은 프로그램은 반복해서 써도 괜찮겠지만, 규모가 커질수록 실수의 위험이 높아집니다.  



이런 문제를 해결하기 위해 전처리기에서 #define으로 매크로를 정의합니다.  

**프로그램9.2**

```c
#include <stdio.h>

#define ARRAY_SIZE 10    

int main(){

    char s1[ARRAY_SIZE];

    for (int i = 0; i < ARRAY_SIZE; i++){
        s1[i] = 97 + i;
    }

    for (int i = 0; i < ARRAY_SIZE; i++)  {
        printf("%c ", s1[i]);
    }

    return 0;
}
```

**실행 결과**

```
a b c d e f g h i j
```

1. #define을 이용해 배열 크기를 10으로 정했습니다.  

2. 그리고 프로그램9.1에서 10이 들어가는 부분에 새로 정의한 ARRAY_SIZE를 사용했습니다.  



위처럼 #define을 기호 상수로 이용할 수도 있습니다.  

예를 들어  

```c
#define PI 3.14
#define NULL 0
```



## 매개 변수를 갖는 매크로

#define으로 함수 모양의 매크로도 정의할 수 있습니다.  

```
#define PRINT_NUM(x) printf("%d\n", x)
```

위에서는 x가 매개 변수가 되는데,  

이런 함수 모양의 매크로를 정의할 때는 괄호 안에 자료형은 생략하고 인수의 이름만 지정합니다.  

함수처럼 생긴 매크로지만, 매크로만의 특징이 있습니다.  

- 매크로는 인자의 형을 검사하지 않습니다.  
- 매크로는 인자를 여러 번 평가하기 때문에, 괄호를 사용해 올바른 평가 순서를 유지해야 합니다.

**프로그램 9.3** 은 함수처럼 생긴 매크로를 사용한 예제입니다.  

 ```
#include <stdio.h>

// a와 b를 곱함
#define MUL(a, b) a * b

// a와 b를 더함
#define ADD(a, b) a + b

int main()
{
    printf("%d\n", MUL(10, 20));          // (1). 200: 10 * 20
    printf("%d\n", MUL(1 + 2, 3 + 4));    // (2). 11: 1 + 6 + 4, 2 * 3이 먼저 계산됨

    printf("%d\n", ADD(1, 2));        // (3). 3: 1 + 2
    printf("%d\n", ADD(1, 2) * 3);    // (4). 7: 1 + 6, 2 * 3이 먼저 계산됨

    return 0;
}
 ```

**프로그램 결과**

```
200
11
3
7
```



먼저 `#define` 키워드를 이용해 인자 두 개를 곱하는 MUL과, 인자 두 개를 더하는 ADD를 만들었습니다.  

4줄의 `printf` 문장을 하나씩 살펴보겠습니다.  

1. MUL(10, 20) 입니다. 위에서 정의한대로 10*20을 합니다.  

2. MUL(1 + 2, 3 + 4) 입니다.  

   아마 이 문장의 의도는 MUL(3, 7) = 21 이었을 것입니다.  하지만 출력은 11입니다.

   매크로의 특징을 기억해야 합니다.  

   - 매크로는 인자를 여러 번 평가하기 때문에, 괄호를 사용해 올바른 평가 순서를 유지해야 합니다.

   컴파일러는 MUL(1 + 2, 3 + 4) 라는 문장을 보고 이렇게 해석했을 것입니다.  

   ```
   1 + 2 * 3 + 4
   ```

   매크로를 정의할 때는 연산자 우선순위에 영향을 받지 않도록 인수와 결과를 괄호로 묶어주어야 합니다.  

   괄호로 묶어주지 않으면 우선순위가 높은 연산자가 먼저 계산됩니다.  

   의도한 결과를 유도하려면 어떻게해야 할까요?

3.  ADD(1, 2) 입니다. 1번과 같습니다.  

4.  ADD(1, 2) * 3 입니다. 아마 이 문장의 의도는 ADD(1, 2) = 3을 계산한 후 거기에 *3을 하려는 것일 겁니다.  

   하지만 컴파일러는 이 문장을  

   ```
   1 + 2 * 3
   ```

   으로 해석해 연산자 우선순위에 의해 2*3이 먼저 계산되고 거기에 +1을 한 7이라는 결과가 나왔습니다.  

이런 현상을 막기 위해서는 괄호를 잘 활용해야 합니다.  

자세한건 연습 문제에서 살펴보도록 합시다.  



## #연산자

#연산자는 쉽게 말해 **문자열화** 연산자입니다.  

변수를 문자열로 변환시킵니다.  

```
#define PRINT_NUM(a) printf("%s: $d\n", #a, a)
```

이런 매크로의 출력은 어떻게 될까요?  

```
...
int count = 100;
PRINT_NUM(count);
```

**출력**

```
count: 100

```

즉, 매개 변수로 들어온 count라는 이름의 변수를  

#a가 문자열 "count"로 변환시킨 것입니다.  



## 헤더 파일

프로그램을 만들 때, 하나의 파일에 모든 코드를 넣지 않습니다.  

여러 개의 파일을 관리하게 되는데, #include 연산자를 이용하여 서로 다른 파일에 있는 함수나 선언 내용을 사용할 수 있게 해줍니다.  

쉽게 말해 다른 파일을 포함시켜주는 것입니다.  

- #include 뒤에 파일 명은 2가지 경우가 있습니다.  
  1.  표준 라이브러리(ex. stdio.h) 등은 < > 로 감쌉니다. 
  2.  사용자 개인 임의 파일 등 비표준 파일은 " " 로 감쌉니다.

예제를 보면 이해가 쉬울 것 같습니다.  

```c
#include <stdio.h>
#include "add.h"

int main()
{

    printf("%d\n", add(1, 2));

    return 0;
}
```

위 코드는 main.c입니다.  

우리는 main.c에 딱 저 문장만 들어가게 해서  3 이라는 결과를 얻을 것입니다.  

어떻게 해야할까요?  

두 번째 줄에 보면 `#include "add.h"` 가 보이시죠?  

위에서 설명한 특징 **사용자 개인 임의 파일 등 비표준 파일은 " " 로 감쌉니다.** 의 예시입니다.  

그렇다면 add.h 라는 헤더파일을 만들어야 할 것입니다.  



**add.h**(헤더파일)

```
int add(int num1, int num2);
```

헤더 파일에는 함수의 원형만 적어놓고  

**헤더파일과 이름이 똑같은 .c파일(구현파일)** 을 만듭니다.  



**add.c**(구현파일)

```
#include "add.h"

int add(int num1, int num2){
	return num1 + num2;
}
```

구현 파일에는 헤더 파일에서 선언했던 함수 원형을 구현합니다.  

구현 파일은 헤더 파일을 당연히 포함해야 할 것입니다.  

**실행결과(main.c)**

```
6
```



add.h 헤더 파일을 add.c 구현 파일을 이용해 구현한 뒤,  

main.c 파일에 add.h 헤더 파일을 추가하여 main.c에서도 add함수(add.h에서 선언한)를 사용할 수 있었습니다.  

지금은 add함수 하나라 필요성을 느끼지 못하겠지만, 구현해야 하는 함수의 갯수가 수십 수백개로 늘어난다면 이 작업은 선택이 아니라 필수일 것입니다.  

또한 꼭 알아야 할 것은 **헤더파일에는 함수 원형만 적어야 하고 구현 파일은 따로 만들어야 한다는 것입니다.**





## 디버깅 코드

C언어에서  

```
#ifdef 매크로
코드
#endif

```

를 이용해, 원하는 매크로가 정의되어 있을 때만 컴파일 할 수 있습니다.  

이 기능은 디버그에 보통 많이 사용됩니다.  

**프로그램9.4**

```
#include <stdio.h>

#define DEBUG    // DEBUG 매크로 정의

int main()
{
#ifdef DEBUG     // DEBUG 매크로가 정의되어 있다면 #ifdef, #endif 사이의 코드를 컴파일
    printf("Debug: %s %s %s %d\n", __DATE__, __TIME__, __FILE__, __LINE__);
#endif

    return 0;
}
```

**실행 결과**

```
Debug: Oct  6 2015 23:30:18 c:\project\hello\conditional_compile\conditional_compile.c 8
```



```c
#ifdef DEBUG     
    printf("Debug: %s %s %s %d\n", __DATE__, __TIME__, __FILE__, __LINE__);
#endif
```

이 단락을 살펴보면, #ifdef DEBUG 이니까 DEBUG라는 매크로가 정의되어 있어야만 사용 가능하다는 뜻입니다.  

**참고**

```
__DATE__, __TIME__, __FILE__, __LINE__
```

는 컴파일러에서 제공하는 매크로이며, 디버그를 작성할 때 유용합니다.  

- __DATE__: 컴파일한 날짜(실행 시점의 현재 날짜가 아님)
- __TIME__: 컴파일한 시간(실행 시점의 현재 시간이 아님)
- __FILE__: __FILE__ 매크로가 사용된 헤더, 소스 파일
- __LINE__: __LINE__ 매크로가 사용된 줄 번호  



만약 **프로그램 9.4**가 전처리 과정을 거치면

```
#ifdef DEBUG    
    printf("Debug: %s %s %s %d\n", __DATE__, __TIME__, __FILE__, __LINE__);
#endif

```

이 부분은  

```
printf("Debug: %s %s %s %d\n", __DATE__, __TIME__, __FILE__, __LINE__);

```

로 바뀔 것입니다.  

### 다음 단계
- [실습문제로...](./실습문제.md)
- [다음 강좌로...](../10강%20-%20입력과%20출력/강의자료.md)

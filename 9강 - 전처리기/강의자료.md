# 전처리기

## 목차

[1. 전처리기](#전처리기)

[2. 매크로](#매크로)

[3. 매개 변수를 갖는 매크로](#매개-변수를-갖는-매크로)

[4. #연산자](#연산자)

[5. 헤더 파일](#헤더-파일)

[6. 디버깅 코드](#디버깅-코드)

## 전처리기

C 언어에서는 컴파일러에 특정 작업을 지시하는 전처리기를 제공합니다.  

보통 전처리기는 반복되는 값이나 작업을 미리 정의할 때 사용하며,  

컴파일 옵션 설정이나 조건부 컴파일도 가능합니다.  

#으로 시작하는 행을 전처리 지시자라고 하며,  

프로그램 개발과 유지보수를 쉽게, 가독성을 높이는 역할을 합니다.  

전처리기는  

- 컴파일러가 컴파일을 시작하기 전에 미리 처리해주는 것입니다.

- #으로 시작합니다.  

- 문장을 끝낼 때 세미콜론(;)을 붙이지 않습니다.  

- C언어의 나머지 부분과 독립적입니다.  

  

## 매크로

C언어에서 #define으로 매크로를 정의하는 법을 알아봅시다.  

예를 들어, 배열이나 동적 메모리를 할당한 포인터는 반복문과 함께 사용하는 경우가 많습니다.  

보통 배열, 메모리 크기만큼 반복하면서 값을 출력하거나 저장하기 때문입니다.  

**프로그램 9.1** 은 배열을 선언한 뒤, 문자를 저장하고 하나씩 출력하는 프로그램입니다.  

```
#include <stdio.h>

int main(){

    char s1[10];   

    for (int i = 0; i < 10; i++){
        s1[i] = 97 + i;
    }

    for (int i = 0; i < 10; i++)   {
        printf("%c ", s1[i]);
    }

    return 0;
}
```

**실행 결과**

```
a b c d e f g h i j
```

먼저 문자 10개 크기의 배열을 선언하고  

두개의 반복문을 배열 크기만큼 반복했습니다.  



코드를 살펴보면 배열의 크기인 10이 계속해서 반복된다는 것을 알 수 있습니다.  

이런 짧은 프로그램은 반복해서 써도 괜찮겠지만, 규모가 커질수록 실수의 위험이 높아집니다.  



이런 문제를 해결하기 위해 전처리기에서 #define으로 매크로를 정의합니다.  

프로그램9.2

```
#include <stdio.h>

#define ARRAY_SIZE 10    

int main(){

    char s1[ARRAY_SIZE];

    for (int i = 0; i < ARRAY_SIZE; i++){
        s1[i] = 97 + i;
    }

    for (int i = 0; i < ARRAY_SIZE; i++)  {
        printf("%c ", s1[i]);
    }

    return 0;
}
```

**실행 결과**

```
a b c d e f g h i j
```

#define을 이용해 배열 크기를 10으로 정했습니다.  

그리고 프로그램9.1에서 10이 들어가는 부분에 새로 정의한 ARRAY_SIZE를 사용했습니다.  



위처럼 #define을 기호 상수로 이용할 수도 있습니다.  

예를 들어  

```
#define PI 3.14
#define NULL 0
```



## 매개 변수를 갖는 매크로

#define으로 함수 모양의 매크로도 정의할 수 있습니다.  

```
#define PRINT_NUM(x) printf("%d\n", x)
```

위에서는 x가 매개 변수가 되는데,  

이런 함수 모양의 매크로를 정의할 때는 괄호 안에 자료형은 생략하고 인수의 이름만 지정합니다.  

- 매크로는 인자의 형을 검사하지 않습니다.  

- 매크로는 인자를 여러 번 평가하기 때문에, 괄호를 사용해 올바른 평가 순서를 유지해야 합니다.

  - 프로그램x.3

  - ```
    #include <stdio.h>
    
    // a와 b를 곱함
    #define MUL(a, b) a * b
    
    // a와 b를 더함
    #define ADD(a, b) a + b
    
    int main()
    {
        printf("%d\n", MUL(10, 20));          // 200: 10 * 20
        printf("%d\n", MUL(1 + 2, 3 + 4));    // 11: 1 + 6 + 4, 2 * 3이 먼저 계산됨
    
        printf("%d\n", ADD(1, 2));        // 3: 1 + 2
        printf("%d\n", ADD(1, 2) * 3);    // 7: 1 + 6, 2 * 3이 먼저 계산됨
    
        return 0;
    }
    ```

    **프로그램 x.3 설명**

    ```
    200
    11
    3
    
    7
    ```

## #연산자

#연산자는 쉽게 말해 "문자열화" 연산자입니다.  

변수를 문자열로 변환시킵니다.  

```
#define PRINT_NUM(a) printf("%s: $d\n", #a, a)
```

이런 매크로의 출력은 어떻게 될까요?  

```
...
int count = 100;
PRINT_NUM(count);
```

**출력**

```
count: 100

```

즉, 매개 변수로 들어온 count라는 이름의 변수를  

#a가 문자열"count"로 변환시킨 것입니다.  



## 헤더 파일

프로그램을 만들 때, 하나의 파일에 모든 코드를 넣지 않습니다.  

여러 개의 파일을 관리하게 되는데, #include 연산자를 이용하여 서로 다른 파일에 있는 함수나 선언 내용을 사용할 수 있게 해줍니다.  

쉽게 말해 다른 파일을 포함시켜주는 것입니다.  

- #include 뒤에 파일 명은 2가지 경우가 있습니다.  
  1.  표준 라이브러리(ex. stdio.h) 등은 < > 로 감쌉니다. 
  2.  사용자 개인 임의 파일 등 비표준 파일은 " " 로 감쌉니다.



[코드 추가 예정 : 파일 두개 만들어서 추가]



## 디버깅 코드

C언어에서  

```
#ifdef 매크로
코드
#endif

```

를 이용해, 원하는 매크로가 정의되어 있을 때만 컴파일 할 수 있습니다.  

이 기능은 디버그에 보통 많이 사용됩니다.  

프로그램x.4

```
#include <stdio.h>

#define DEBUG    // DEBUG 매크로 정의

int main()
{
#ifdef DEBUG     // DEBUG 매크로가 정의되어 있다면 #ifdef, #endif 사이의 코드를 컴파일
    printf("Debug: %s %s %s %d\n", __DATE__, __TIME__, __FILE__, __LINE__);
#endif

    return 0;
}

```

**실행 결과**

```
Debug: Oct  6 2015 23:30:18 c:\project\hello\conditional_compile\conditional_compile.c 8

```



```c
#ifdef DEBUG     
    printf("Debug: %s %s %s %d\n", __DATE__, __TIME__, __FILE__, __LINE__);
#endif

```

이 단락을 살펴보면, #ifdef DEBUG 이니까 DEBUG라는 매크로가 정의되어 있어야만 사용 가능하다는 뜻입니다.  

참고로

```
__DATE__, __TIME__, __FILE__, __LINE__

```

는 컴파일러에서 제공하는 매크로이며, 디버그를 작성할 때 유용합니다.  

- __DATE__: 컴파일한 날짜(실행 시점의 현재 날짜가 아님)
- __TIME__: 컴파일한 시간(실행 시점의 현재 시간이 아님)
- __FILE__: __FILE__ 매크로가 사용된 헤더, 소스 파일
- __LINE__: __LINE__ 매크로가 사용된 줄 번호  



만약 프로그램 x.4가 전처리 과정을 거치면

```
#ifdef DEBUG    
    printf("Debug: %s %s %s %d\n", __DATE__, __TIME__, __FILE__, __LINE__);
#endif

```

이 부분은  

```
printf("Debug: %s %s %s %d\n", __DATE__, __TIME__, __FILE__, __LINE__);

```

로 바뀔 것입니다.  


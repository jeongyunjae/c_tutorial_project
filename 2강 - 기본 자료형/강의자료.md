# 기본 자료형

## 목차
[1. 서론](#서론)  
[2. 자료형](#자료형)  
[3. 기본 규칙](#기본-규칙)  
[4. 정수](#정수)  
[5. 실수](#실수)  
[6. 문자](#문자)  
[7. 논리형 변수](#논리값)    
[8. 자료형 크기](#자료형-크기)   
[9. 자료형 변환](#자료형-변환)  

## 서론

프로그램에는 정수, 실수, 문자 등 다양한 데이터가 사용됩니다.

`1 , 3.14 , 'a' , '@' `같은 데이터 값들을 상수 라고 합니다.

데이터 값을 number, symbol 같은 이름에 저장할 수 있는데 이렇게 저장되는 이름을 '변수'라고 합니다.

변수는 바뀔 수 있는 어떤 값을 보관하는 곳으로 값은 변경할 수 있습니다.


## 자료형

컴퓨터는 꺼진 상태를 0, 켜진 상태를 1로 구분하며 두 가지 상태 (0 과 1) 형태만 이해하고 사용합니다.

0 과 1 로만 이루어진 표현법을 '2진수'라고 하며 `비트(bit)`라는 단위에 담을 수 있습니다.

비트를 묶어서 다양한 상태를 표현할 수 있는데 비트 8개 단위를 `바이트(byte)` 라고 합니다.

바이트들이 연속적으로 있는 기억공간을 `메모리`라고 합니다.

C프로그램에서 데이터는 메모리에 저장됩니다.

숫자인지 문자인지 크기가 큰지 작은지 종류에 따라 메모리를 차지하는 크기가 달라집니다.

이러한 데이터들의 형태를 구분지어 놓은 것을 자료형이라고 합니다.

C 프로그램의 모든 변수는 자료형이 명시되어야 합니다.

- 기본 자료형 ( 정수,  실수,  문자 )

- 사용자 자료형



**프로그램 4.1**

```c
#include <stdio.h>
int main(void){
  int i;
  i = 65;
  printf("정수 ? : %d\n", i);
  printf("실수 ? : %f\n", i);
  printf("문자 ? : %c\n", i);
  return 0;
}
```
---
**프로그램 결과**  
```
정수 ? : 65  
실수 ? : 0.000000  
문자 ? : A  

같은 65 라는 값이지만 자료형에 따라 다른 값이 나옵니다.
```


## 기본 규칙

한글이나 영어를 사용할 때에도 문법이 중요합니다.

서로 원활한 이해를 위해선 정해진 규칙 안에서 문장을 구성해야 합니다.

`나는 밥을 먹었다.`

`먹었다 밥을 나는`

같은 문자들로 되어있지만 순서에 따라서 이해가 안될 수 있습니다.

컴퓨터에 원하는 계산을 시키기 위해선 몇 가지 규칙을 지켜서 프로그램을 작성해야합니다.


## 선언문  

모든 변수는 사용되기 전에 반드시 선언되어야 합니다.

- 자료형 변수이름;

- 자료형 변수이름_목록;  

**변수 이름 선언 규칙**

- 변수 이름 중 자료형이나 명령어로 쓰이는 단어들을 사용할 수 없습니다.

- 이름 사이에 공백이 있으면 안됩니다.

- 첫 글자에 숫자를 쓰면 안됩니다.

- 대소문자를 구별합니다.

- `_`를 제외한 대부분의 특수문자는 변수 이름으로 사용할 수 없습니다.


>선언문 예제    
```c
int i;					// 변수를 선언합니다.

int I;					// 대소문자를 구별합니다.

i = 20;					// 변수에 값을 넣어줍니다.

int a = 10;				// 변수를 선언하면서 값을 넣어줍니다.

float x, y;  			// 변수 목록을 선언합니다.

float w = 2.1, k = 3.3; // 변수 목록을 선언할 때도 값을 넣어줄 수 있습니다.

int c = i + a;			// 변수 c 에 i + a = 10 + 20 = 30 의 값을 넣어줍니다.


int float				// *에러* 	float은 변수 이름으로 사용할 수 없습니다.
    
int a pple; 	        // *에러*   이름에 공백이 있습니다.

int 123e;				// *에러*   첫글자에 숫자가 있습니다.

z = 10;					// *에러*   z 가 선언되기 전에 사용되었습니다.

int z;
```


**프로그램 4.2**  
```c
#include <stdio.h>
int main(void){
  int num1, num2, num3, multiply;
  float fnum1, fnum2, fmultiply;

  printf("두 정수를 입력하세요 : ");
  scanf("%d%d", num1 * num2);
  multiply = num1 * num2;
  fnum1 = num1;
  fnum2 = num2;
  fmultiply = fnum1 * fnum2;
  printf("%d * %d = %d \n", num1, num2, multiply);
  printf("%.2f * %.2f = %.2f\n", fnum1, fnum2, fmultiply);
  return 0;
}
```
---
**프로그램 결과**  
```
두 정수를 입력하세요 : 4 3  
4 * 3 = 12  
4.00 * 3.00 = 12.00  

```



## 수식

변수와 상수 그리고 연산자로 계산한 식을 수식이라고 합니다.

> 수식 예제
```c
30
'c'
a
a + b
c = a + b
```
## 문장

수식 뒤에 세미콜론이 오면, 수식은 문장이 됩니다.

> 문장 예제
```c
3.777;

a + b;
```

## 정수

변수는 메모리에 저장되고 메모리는 바이트가 연속적으로 나열되어 있는 저장공간입니다.

그리고 바이트들은 8개의 비트로 이루어져 있습니다.

컴퓨터가 데이터를 저장하고 사용할 때 0과 1만 이용한다고 했는데 어떻게 0과 1로 다양한 수를 나타낼까요?

일반적으로 정수를 저장하는 자료형으로 `int`를 사용합니다.

`int`는 4바이트를 차지합니다.

4바이트는 32비트 (4 * 8)로 이루어져있습니다.

2진수를 사용하면 2의 제곱마다 자릿수가 올라갑니다.

|2진수|10진수|
|---|---|
|0|0|
|1|1|
|10|2|
|11|3|
|100|4|
|1000|8|
|10000|16|

이러한 형식이면 32비트로 2^32 에 가까운 큰 수까지 표현할 수 있을 것입니다.

그런데 `-1` 같은 음수도 표현하기 위해서 첫번째 비트를 부호로 사용합니다.

첫번째 비트가 1 이면 음수, 0이면 양수를 나타냅니다.

나머지 31 비트로 숫자를 표현합니다.

음수를 나타내려면 첫번째 비트를 1로 표현하고 연산을 위해서 0과 1을 서로 바꾸는 `보수`를 통해 연산이 필요한데
아래의 예시를 통해 보여드리겠습니다.

> 정수의 표현

|1|2 3 ... 32|
|---|---|
|부호|표현할 수의 2진수|

>양수 예제
```
341의 2진수   

0000000 00000000 00000001 01010101   
부호 0
```
>음수 예제  
```
341의 2진수  
0000000 00000000 00000001 01010101   

1의 보수 ( 0 을 1 로 , 1 을 0 으로 바꿉니다.)   
1111111 11111111 11111110 10101010  

1의 보수 + 1   
1111111 11111111 11111110 10101011  
```

## int 자료형

정수 자료형은 크기에 따라서 자료형을 사용할 수 있습니다.  
```
2 바이트 : short  

4 바이트 : int  

8 바이트 : long, long long  


short 자료형은 기억장소를 절약하고자 하는 경우에 사용합니다.  
long과 long long 형은 큰 정수 값을 다룰 때 사용합니다.  
```

8바이트가 최대로 그것보다 더 큰 정수를 표현할 수 없습니다.

첫 번째 비트를 음수를 사용하는데 쓰는 자료형을 `signed` 라고 합니다.

기본적으로 자료형들은 `signed` 가 생략되어있습니다.

자료형 앞에 `unsigned`를 붙여주면 첫 번째 비트도 숫자를 표현하는데 사용합니다.

따라서 `unsigned`형의 변수는 음수가 아닌 정수를 표현할 때 사용합니다.  


**프로그램 4.4**  
```c
#include <stdio.h>
#include <limits.h>
int main(void)
{
  printf("int 최소 값 : %d\n", INT_MIN);
  printf("int 최대 값 : %d\n", INT_MAX);
  return 0;
}  
```

---
**프로그램 결과**
4바이트 컴퓨터인 경우
```
int 최소 값 : -2147483648  
int 최대 값 : 2147483647  
```

2바이트 컴퓨터인 경우
```
int 최소 값 : -32768  
int 최대 값 : 32767
```

|자료형|크기  (바이트)|범위|변환 명세|
|---|---|---|---|
|short|2|-2^15 ~ 2^15 - 1  (약 +- 3만)|%hd, %hx, %ho|
|int|4|-2^31 ~ 2^31 - 1  (약 +- 21억)|%d, %x, %o|
|long|8|-2^31 ~ 2^31 - 1  (약 +- 21억)|%ld, %lx, %lo|
|long long|8|-2^63 ~ 2^63 - 1  (약 +- 922경)|%lld, %llx, %llo|



## 실수

실수는 소수 부분도 있기 때문에 정수 부분과 소수 부분을 구분 지어서 표현해야합니다.

그러기 위해서 모든 수를 지수 형태로 변환하여 부호, 지수, 가수부로 나누어 저장합니다.

실수도 정수형처럼 크기에 따라 나뉘는데 4바이트에 저장하는 `float` 과 8바이트에 저장하는 `double` 이 있습니다.

## 실수의 표현

> float

|0|1~8|9~31|
|---|---|---|
|부호|지수부|가수부|  


> double

|0|1~11|12~63|
|---|---|---|
|부호|지수부|가수부|


> float, double, long double
```c
float : 4바이트

double : 8바이트

long double : 시스템 종속적
```


|자료형|크기  (바이트)|범위|변환명세|
|---|---|---|---|
|float|4|10^-38 ~ 10^+38|%f, %e, %g, %a|
|double|8|10^-308 ~ 10^+308|%f, %e, %g, %a|
|float double|?|?|%Lf, %Le, %Lg|


**프로그램 4.9**  
```c
#include <stdio.h>
int main(void)
{
  float x = 8.8888888888888888888;   // 20개의 8
 
  printf("x = %.20f\n", x);
  return 0;
}
```

---
**프로그램 결과**  
```
x = 8.88888931274414062500
```
전부 8이 나와야하는데 그렇지 않았습니다.  
이러한 이유는 정수 산술 연산과 달리 부동형 산술 연산은 정확하지 않기 때문입니다.

## 실수 표기법

실수를 표현할 때는 `0.01` 같이 고정적인 상수로 표현할 수도 있지만
지수를 이용해 표기할 수도 있습니다.

`1.00e+03` 처럼 표기할 수 있는데 표기법들을 알아보겠습니다.

> 실수 표현
```c
3.14159   
314.159e-2F // float 형으로 쓰고 싶을 때 f, F 를 붙이면 됩니다.
0e0   
1.			// 소수점 아래부분을 생략하는 것도 가능합니다.


// 잘못된 표기법
3.14,159
34159
.e
```

## 문자

모든 정수형의 변수는 문자를 표현하는 데 사용될 수 있습니다.

문자도 컴퓨터에 저장될 때에는 0과 1의 비트열로 저장됩니다.

문자를 비트열로의 변환은 'ASCII'라고 하는 표준에 따라 변환됩니다.

## char 자료형

char 형 변수는 문자와 정수 값을 저장하는 데 사용됩니다.

char는 메모리의 1 바이트에 저장됩니다.

`(signed) char`형은 -128 ~ 127의 범위를 `unsigned char`형은 0 ~ 255의 범위를 표현합니다.


## ASCII

|||
|---|---|
|문자 상수|'a' 	'b' 	'c' 	...  'z'|
|대응하는 값|97 	98 	99 	...  122|
|문자 상수|'A' 	'B' 	'C' 	...  'Z'|
|대응하는 값 |65 	66 	67 	...   90|
|문자 상수 |'0' 	'1' 	'2' 	...  '9'|
|대응하는 값| 48 	49 	50 	...   57|
|문자 상수 |'&' 	'*' 	'+'|
|대응하는 값 | 38 	42 	43|


**프로그램 4.5**  
```c
#include <stdio.h>
int main(void)
{
  char c = 'a';
  int d = 'a';
  
  printf("c = %c\n", c);
  printf("c = %d\n\n", c);
  printf("d = %c\n", d);
  printf("d = %d\n", d);
  return 0;
}
```
---
**프로그램 결과**  
```c
c = a
c = 97

d = a
d = 97
```



## 논리값

어떤 값이나 조건이 참인지 거짓인지만 알고 싶을 때가 있습니다.

이럴 때 참인지 거짓인지를 저장할 수 있는 `_Bool`형을 사용할 수 있습니다.

`_Bool`형의 0은 거짓을 의미하고 1은 참을 의미합니다.

<stdbool.h>헤더파일을 이용하면 문자 그대로 의미인 `true`로 참을 `false`로 거짓을 나타낼 수 있습니다.


> 논리 값 사용 예
```c
if(a == true){
  printf("값이 참입니다");
}
```

**프로그램 4.8**  
```c
#include <stdio.h>
#include <stdbool.h>
int main(void){
  bool a, b, c;      // Bool  a, b, c;

  a = true;          // a = 1;
  b = false;         // b = 0;
  c = 324;
  printf("a = %d, b = %d, c = %d\n", a, b, c);
  return 0;
}
```

---
**프로그램 결과**  
```c
a = 1, b = 0, c = 1

// 표현은 true, false 이지만 1과 0으로 표현할 수 있습니다.
```


기본 자료형 정리
---
|||||
|---|---|---|---|
|_Bool||||
|char|signed char|unsigned char|
|short|int|long|long long|
|unsigned short|unsigned int|unsigned long|unsigned long long|
|float|double|long double|
|float _Complex|_Complex|long double _Complex|
|float _Imaginary|_Imaginary|long double _Imaginary|

## 오버플로
큰 값의 계산을 하다보면 지정한 자료형보다 큰 값이 들어갈 수 있습니다.

이럴 때 프로그램이 종료되지는 않지만 논리적으로 맞지 않는 값이 들어가는데 이것을 `오버플로(overflow)` 라고 합니다.


**프로그램 4.6**  
```c
#include <stdio.h>
int main(void)
{
  long long v1, v2, v3;
  
  v1 = v2 = 9000000000000000000LL;		//900경
  v3 = v1 + v2;                         // 900 경 + 900 경 = 1800경?  
  printf("%lld + %lld = %lld\n", v1, v2, v3);
  return 0;
}
```
---
**프로그램 결과**
```c
9000000000000000000 + 9000000000000000000 = -446744073709551616
    
```
원하는 값이 아닌 음수의 값이 나왔습니다.  
이를 통해 범위를 벗어나는 값을 표현할 수 없다는 것을 알 수 있습니다.



## 자료형 크기
## sizeof

자료형이나 변수, 수식의 바이트 수를 알아내기 위해 사용합니다.

> sizeof  사용법

```c
sizeof(int)		// int의 크기를 알려줌(괄호를 생략할 수 없음)

sizeof(c)		// c의 크기를 알려줌 (괄호를 생략할 수 없음)

sizeof(a + b)	// a + b의 형의 크기를 알려줌

sizeof a + b	// (sizeof a) + b
```

## 자료형 변환

자료형이 다른 변수나 상수끼리 연산을 하게 되면 계산을 위해서 한 쪽으로 자료형을 변환해줍니다.

이러한 변환은 사용자가 직접 자료형을 바꿔줄 수도 있고 따로 작성하지 않아도 컴파일러가 자동으로 합니다.

기본 규칙은 범위가 작은 쪽이 큰 쪽으로 변환됩니다.

_Bool, char, signed char, unsigned char, signed short, unsigned short 등은 연산을 할 때 int로 변환됩니다.

int형은 float형과 계산하게 되면 float형이 double형과 계산하면 double형으로 변환됩니다.

> 변환 예
```c
char a, b, c;
c = a + b;     // a와 b는 int로 정수 승격됨
```

```c
char c; 
unsigned short s; 
int i; 
long l; 
float f; 
double d;
long double ld;

i = c + s + f + l + d;

c - s / i          -> int
c + 3			   -> int
c + 5.0			   -> double
d + s              -> double
2 * i / l          -> long
f * 7 - i          -> float
7 * s * ul         -> unsigned long
ld + c             -> long double
u - ul             -> unsigned long

```

## 캐스트

자동적인 변환이 아닌 사용자가 원하는 형으로 변환하는 것을 `캐스트`라고 합니다.

`캐스트`를 할 때에는 자료형을 변환했을 때 자료형이 어떻게 처리되는지 인식하고 있어야합니다.

일반적으로 범위가 작은 변수를 범위가 큰 변수로 변환하는 것은 값의 변화가 없습니다.

하지만 범위가 큰 변수를 작은 자료형으로 변환할 때 참조하는 메모리의 범위가 작아져 값이 달라질 수 있습니다.

`1.23`의 값을 가진 `float`형 변수 A를 `(int)`형으로 캐스트하면 소수 부분을 표현할 수 없어 정수값인 `1` 로 바뀝니다.

이러한 결과는 `float`형 변수를 `int`형 변수에 넣으면 명시하지 않아도 자동으로 일어납니다.

> 캐스트가 필요한 예제
```c
int sum = 9, num = 10;
float avg;
avg = sum / num;      
// 정수 : 정수 나누기 연산은 몫이 나옵니다.
// 나눴을 때 분수의 값을 원한다면 분수 값을 원한다면 실수로 캐스트해야합니다.
```

괄호 안의 자료형을 쓰고 수식 앞에 명시합니다.

```c
(float) sum     // 형을 변환하고자하는 수식 앞에 붙입니다.
```

```c
avg = (float) sum / (float) num
avg = (float) sum / num
(double) (num = 10)
(double) num = 10          // 잘못된 캐스트 double형에 int를 넣고 있습니다.
```

### 다음단계
- [실습문제로...](./실습문제.md)
- [다음 강좌로...](../3강%20-%20제어의%20흐름/강의자료.md)

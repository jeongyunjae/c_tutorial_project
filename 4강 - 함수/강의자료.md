# 함수

## 목차
[1. 서론](#서론)   
[2. 함수 정의](#함수-정의)   
[3. 함수 호출](#함수-호출)    
[4. return](#return)   
[5. 값에 의한 호출](#값에-의한-호출)   
[6. 유효 범위 규칙](#유효-범위-규칙)   
[7. 지역변수와 전역변수](#지역-변수와-전역-변수)  
[8. 기억영역 클래스](#기억-영역-클래스)              
[9. 재귀 함수](#재귀-함수)   

## 서론
C 프로그램을 작성하다 보면 동일한 기능을 하는 코드를 반복해서 사용할 때가 있습니다.

또 다양한 작업을 main() 함수 안에서 다 처리하다보면 코드가 길어져 확인하고 작성하는데 불편합니다.

C 언어에서는 `함수`라는 기능을 통해 특정 코드들을 분리하고 필요할 때 불러올 수 있습니다.

자주 사용했던 printf()나 scanf() 처럼 말입니다.

이렇게 함수를 사용하면 이러한 장점이 있습니다.

- 코드의 재사용이 쉬워집니다.  

- 디버깅이 쉬워집니다.

- 기능마다 분리가 되어있어 유지 보수가 쉬워집니다.



**함수 예제**

```c
#include <stdio.h>
int main(void)                 // 함수 헤더
{                              // 함수 몸체
   printf("hello world\n");
   return 0;
}
```

```c
int hello(void)
{
   printf("hello world\n");
   return 0;
}
```

main() 함수와 hello() 함수는 이름만 다를 뿐 같은 일을 수행하고 있습니다.

hello() 함수는 호출되면 예제의 main() 함수와 똑같은 일을 수행할 수 있습니다.

main() 함수는 프로그램이 실행되면 자동적으로 호출되어 실행되는 반면 hello() 함수는 프로그램에서 호출해야 하는 차이점이 있습니다.

## 함수 정의

함수를 사용하기 위해선 함수에 대한 정보를 정의해야 합니다.

> 함수 정의의 일반적인 형식  

```c
형 함수_이름( 매개변수_목록 )    // 함수 헤더
{                              // 함수 몸체
   코드
}

int hello(char c)              // 함수 헤더
{                              // 함수 몸체
   printf("%c\n",c);
   return 0;
}
```

## 매개 변수

매개 변수는 함수에서 입력 값을 받아 사용할 때 들어가는 변수입니다.

## 매개 변수 규칙

매개 변수를 정의할 때 형이 같다고 해서 변수 이름을 연속해서 사용하면 안됩니다.

> 잘못된 매개 변수 정의 예 
```c
int hello(int a,b){....}

// 제대로 된 정의 
int hello(int a, int b){....}
```

함수를 사용할 때에도 정의한 매개 변수의 형과 갯수에 맞게 써줘야합니다.


함수는 함수 헤더와 몸체로 이루어져 있습니다.

함수 몸체는 사용할 코드를 { } 에 사용할 코드를 작성하면 됩니다.

함수 헤더를 살펴보겠습니다.

> 함수 헤더 
```c
형 함수_이름( 매개변수_목록 )

int hello( int c )
```
- 함수_이름 : 함수를 불러올 때 쓸 이름입니다.

- 매개변수_목록 : 함수에 입력 값을 줘서 코드를 사용할 수 있습니다.

- 형 : 함수가 끝나거나 조건이 맞을 때 값을 반환할 수 있는데 이 값의 자료형을 정할 수 있습니다.



## 함수 호출

정의한 함수를 사용하려면 함수를 호출해야합니다.

> 함수 호출 형태

```c
변수 = 함수_이름(인자_목록);

a = hello( c );
```
변수에는 함수_이름 함수가 반환한 값이 들어옵니다.

변수의 형은 함수의 형과 같아야 됩니다.


> 함수 매개변수 목록이 없을 때의 함수 호출 형태
```c
변수 = 함수_이름( );

a = hello( );
```
함수 매개변수 목록이 `void` 이거나 비어있을 때는 매개변수가 없음을 뜻합니다.

> 함수 형이 void 일 때의 함수 호출 형태
```c
함수_이름(인자_목록);

hello ( c );
```
함수 형이 `void` 라는 것은 함수가 반환하는 값이 없을을 뜻합니다.



**프로그램 호출 예제**
```c
#include <stdio.h>
void print_it(void)         // 리턴 값 없습니다.
{
   printf("재미있는 함수\n");
   return;
}
int main(void)
{
   print_it();
   return 0;
}

#include <stdio.h>
void print_it(void)
{
   printf("재미있는 함수\n");
   return;
}
int main(void)
{
   print_it();
   print_it();
   print_it();           // 필요한 만큼 호출하면 됩니다.
   return 0;
}
```

## return
return 문은 함수를 종료하고 함수를 호출한 곳으로 돌아가는 역할을 합니다.

함수의 반환형이 void 형이 아니면 반환형에 맞게 수식이 변환되어 값을 반환합니다.

return 문이 실행되면 그 이후에 코드는 거치지 않고 함수가 끝납니다.

return 문은 조건에 따라 여러번 나올 수 있지만 하나의 함수에서 한번만 실행됩니다.

> return 예

```c
return;

return ++a;

return (a * b);

if (error)
   return 1;
else
   return 0;
```

>다중 return 문 예제
```c
unsigned long long factorial(int n)
{
   unsigned long long f;
   int   i;
   if (n < 0)
      return -1;     // n이 음수일 때 -1 리턴
   for (f = i = 1; i <= n;  i++)
      f *= i;        // n이 양수일 때 계승 리턴
   return f;
}
```

## 값에 의한 호출

C에서는 함수에서 매개변수를 받을 때 변수 그 자체가 아닌 변수의 값만을 전달 받습니다.

따라서 함수 안에서 값이 바뀌더라도 변수의 값은 변하지 않습니다.

>값에 의한 호출 예제
```c
#include <stdio.h>
int   compute_sum(int);
int main(void)
{
   int   n = 3, sum;
   printf("함수 호출 전 : n = %d\n", n);
   sum = compute_sum(n);
   printf("함수 호출 후 : n = %d\n", n);
   printf("합 = %d\n", sum);
   return 0;
}
int compute_sum(int n)
{
   int sum = 0;
   for ( ; n > 0; --n)	   // n의 값이 변함
      sum += n;
   return sum;            // n == 0
}
```
---
**프로그램 결과**
```c
함수 호출 전 : n = 3
함수 호출 후 : n = 3
합 = 6
```

매개변수의 이름을 바꿔도 똑같은 함수입니다.   

따라서 예제의 compute_sum()을 다음과 같이 수정해도 상관없습니다.

>함수 매개변수 이름 변경 예시
```c
int compute_sum(int x)       // 함수에서 x 이고 main 에서 n 이라는 이름으로 들어와도 상관없습니다.
{
   int s = 0;
   for ( ; x > 0; --x)
      s += x;
   return s;
}
```

## 유효 범위 규칙

main() 함수 내에 있는 변수를 다른 함수에서 사용하려면 매개 변수로 넘겨줘야하듯이 변수는 사용할 수 있는 범위가 있습니다.

함수와 함수 사이가 아니더라도 범위를 구분 지을 수 있는 규칙이 있습니다.

식별자의 유효범위는 그 식별자가 선언된 곳부터 시작하여 식별자가 선언된 블록의 마지막 부분까지 사용할 수 있습니다.

- 그 블록을 벗어나면 사용될 수 없습니다.

외부 블록에 선언된 변수는 내부 블록에서 같은 이름으로 다시 선언되지 않는 한, 내부 블록에서도 유효합니다.
    
- 만일 같은 이름으로 내부 블록에 선언된다면, 외부 블록 변수는 내부 블록에서는 사용할 수 없습니다

```c
{   
      // 블록 A
    int a = 2, b = 4;                           |
    printf("A: a = %d, b = %d\n", a, b);        | 블록 A의 a와 b의 유효범위
    { 
       // 블록 B
        int a;                                  | A의 a와 B의 a는 다른 변수 입니다.
        a = 5;                                  |
        b++;                                    |
        printf("B: a = %d, b = %d\n", a, b);    | 블록 B의 a의 유효범위
    }
    printf("A: a = %d, b = %d\n", a, b);
}
```

## 지역 변수와 전역 변수

지금까지 변수를 선언하고 사용하는 것을 함수 내에서만 했습니다.

이렇게 선언된 변수들은 함수 내에서만 사용이 가능합니다.

이런 변수들을 `지역 변수` 라고 합니다.

이외에 함수 외부에서 변수를 선언할 수 있는데 이런 변수를 `전역 변수` 라고 합니다.

전역 변수는 모든 함수에서 사용이 가능합니다.

**지역 변수와 전역 변수 예제**
```c
#include <stdio.h>
int   a = 0, b = 0, c = 0;	// 전역 변수
int   f(void);
int main(void){
   a = 1;
   b = 2;
   printf("a + b = %d\n", f());
   printf("a = %d, b = %d, c = %d\n", a, b, c);
   return 0;
}
int f(void){
   int   c;			      // 지역 변수
   c = a + b;
   return c;
}
```
---
**프로그램 결과**
```c
a + b = 3
a = 1, b = 2, c = 0

함수 내부에서 다시 선언된 c는 지역 변수로 함수가 종료되고 나서 메모리에서 지워집니다.
함수 f에서 전역 변수 c의 값은 바뀌지 않았으므로 값은 처음처럼 0입니다.
```

함수는 하나의 값만을 반환합니다.

여러 개의 변수를 변경하고 싶을 떄 전역변수를 이용해 쉽게 변경할 수 있습니다.

하지만 전역 변수는 다른 함수에서도 사용이 가능하기 때문에 부작용이 발생할 수 있습니다.

따라서 여러 개의 변수를 변경하고 싶을 때는 이후에 배울 `포인터`를 통해 변경합니다.

전역변수는 주로 함수에서 공통적으로 사용하지만 값이 고정된 상수일 때 사용합니다.
  
## 기억영역 클래스

C 프로그램에서 함수와 변수는 자료형을 지정해준 것을 알 수 있습니다.

자료형 외에도 함수와 변수는 `기억영역 클래스` 를 지정할 수 있습니다.

`기억영역 클래스`는 사용할 수 있는 범위와 메모리에 저장되어 있는 기간을 지정합니다.

기본적으로 기억영역 클래스는 자동, 외부, 정적 기능으로 각각 `auto`, `extern`, `static`을 통해 지정합니다.  

## auto

함수의 몸체에서 선언된 변수는 기본값으로 `auto`로 지정됩니다.

`auto`를 사용하여 기억영역 클래스를 명시할 수도 있지만 생략 가능합니다.

> auto 변수 선언 예
```c
auto int   i, j, k;     // int   i, j, k;
```

블록을 들어갈 때, 자동 변수들을 위해 메모리가 할당됩니다.

블록을 빠져나갈 때, 자동 변수가 할당 받은 메모리는 회수합니다.

## extern

함수 밖에서 선언된 변수의 기억영역 클래스는  기본적으로 `extern`으로 지정됩니다.

앞에서 다룬 전역 변수는 외부 변수로 볼수 있습니다.

외부 변수를 정의할 때 extern을 명시하고자 한다면 그 외부 변수를 반드시 초기화해야 합니다.
- extern이 붙은 선언문에서 변수가 초기화되지 않는 다면, 이는 외부 변수를 선언하는 것입니다.
> 외부 변수 정의
```c
extern int quotient = 0, rem = 0;
```
> 외부 변수 선언
```c
extern int quotient, rem;
```

외부 변수는 프로그램이 종료될 때까지 메모리에 계속 남아 있게 됩니다.

함수들 간에 정보 전달을 위해 종종 사용 됩니다.

전역변수에서 설명했듯이 사용하기는 편하지만 부작용이 발생할 수 있기 때문에 좋은 방법은 아닙니다.

외부 변수는 자동적으로 0으로 초기화 됩니다.

함수는 기본적으로 `extern` 으로 선언되어 있습니다.

따라서 `extern`을 생략해도 상관없으며 어느 함수에서든 공통적으로 사용할 수 있습니다.

**extern 예제**
```c
int main(void){
   int a = 10, b = 3;
   extern int   quotient, rem;
   if (divide(a, b))
      printf("0으로 나눌 수 없습니다.\n");
   else
      printf("%d / %d : 몫은 %d이고 나머지는 %d입니다.\n",
             a, b, quotient, rem);
   return 0;
}
int divide(int dividend, int divisor){
   extern int   quotient, rem;
   if (is_zero(divisor))
      return -1;
   quotient = dividend / divisor;
   rem = dividend % divisor;
   return 0;
}
int   quotient, rem;  	// 외부 변수 정의
//extern int quotient = 0, rem = 0;  
```


## static

정적 변수는 지역 변수와 전역 변수 모두 적용할 수 있습니다.

정적 변수는 지역 변수의 특성과 전역 변수의 특성을 모두 가지고 있습니다.

지정한 범위 내에서만 사용할 수 있지만 프로그램이 종료될 때까지 데이터의 값이 메모리에 남아있습니다.

`static` 을 통해 지정하는데 전역 변수에 사용하게 되면 전역 변수처럼 모든 함수에서 사용할 수 있습니다.

하지만 정적 변수를 선언한 소스코드 내에서만 사용할 수 있습니다.

이를 외부 정적 변수라고 부릅니다.

`static` 을 함수 내부의 변수에 선언하게 되면 변수를 선언한 함수 내부에서만 사용할 수 있습니다.

함수가 종료되면 값이 초기화되던 자동 변수와 다르게 프로그램이 종료될 때까지 값이 남아 있습니다.

정적 변수는 기본적으로 0으로 초기화됩니다.

**내부 정적 변수 예제**
```c
#include <stdio.h>
int count(){
   static int num;		         // 초기화 하지 않으면 0으로 초기화됩니다.
   return ++c;
}
int main(void){
   for(int i = 0; i < 5; i++)
   printf("num = %d\n", count());
   return 0;
}
```
---
**프로그램 결과**
```c
num = 1
num = 2
num = 3 
num = 4 
num = 5

함수가 종료되도 값이 사라지지 않고 남아있습니다.
```



## 재귀 함수

자기 자신을 호출하는 함수를 `재귀 함수`라고 합니다.

**재귀 함수 예제**
```c
#include <stdio.h>
int main(void)
{
   printf("끝나지 않는 재귀 함수...\n");
   main();
   return 0;
}
```
---
**프로그램 결과**
```c
끝나지 않는 재귀 함수...
끝나지 않는 재귀 함수...
끝나지 않는 재귀 함수...
끝나지 않는 재귀 함수...
끝나지 않는 재귀 함수...
끝나지 않는 재귀 함수...
       .
       .
       .
```

위에 예제처럼 프로그램이 종료되는 설정이 없으면 재귀 함수는 무한 루프에 빠지게 됩니다.

따라서 재귀함수를 사용할 때에는 종료하는 지점을 만들어줘야합니다.

재귀함수를 이용하면 함수를 조금 더 이해하기 쉽고 간단하게 만들 수 있습니다.

많은 문제들은 재귀적인 방법과 반복적인 방법 둘 모두로 해결할 수 있습니다.

전형적으로, 재귀가 더 간결하고 같은 계산을 하는 데 더 적은 변수를 필요로 합니다.

반면, 재귀는 각 호출을 위한 인자와 변수를 스택에 쌓아두어 관리하기 때문에 많은 시간과 공간을 요구합니다.

즉, 재귀를 사용할 때에는 비효율성을 고려해야 합니다.

그러나 일반적으로 재귀적 코드는 작성하기 쉽고, 이해하기 쉬우며, 유지보수하기가 쉽습니다.


**피보나치 재귀 호출 예제**
```c
#include <stdio.h>
int factorial_r(int n);
int main(void){
   int n = 5;
   printf("%2d! = %9d\n", n, factorial_r(n));
   return 0;
}
int factorial_r(int n){
   if (n == 0)
      return 1;
   else
      return (n * factorial_r(n - 1));
}
```

```c
factorial_r(5)를 호출했을 때, 재귀호출 되는 과정

factorial_r(5) : return (5 * factorial_r(4))

factorial_r(4) : return (4 * factorial_r(3))

factorial_r(3) : return (3 * factorial_r(2))

factorial_r(2) : return (2 * factorial_r(1))

factorial_r(1) : return (1 * factorial_r(0))

factorial_r(0) : return 1
```



**피보나치 반복 함수**
```c
int fibonacci_i(int n)
{
   int i, tmp, fib = 1, fib_p = 0;
   if (n <= 1)
      return n;   
   for (i = 2; i <= n; i++){
      tmp =  fib;
      fib += fib_p;
      fib_p = tmp;
   }
   return fib;
}
``` 

피보나치 수열의 정의

                 | 0,                    if  i = 0
        f1 =     | 1,                    if  i = 1
                 | fi-1  + fi-2 ,        if  i > 1

**피보나치 재귀 함수**
```c
int fibonacci_r(int n)
{
   if (n <= 1)
      return n;
   else
      return (fibonacci_r(n - 1) + fibonacci_r(n - 2));
}

피보나치 수열의 정의를 거의 그대로 사용하여 이해하기 쉽습니다.
```

> n 값에 따른 fibonacci_r() 함수 호출 개수

|n|fibonacci_r(n)의 값|fibonacci_r() 함수가 호출되는 횟수|
|---|---|---|
|0|0|0|
|1|1|1|
|2|1|3|
|...|...|...|
|23|28657|92735|
|42|267914296|866988873|  

### 다음 단계
- [실습문제로...](./실습문제.md)
- [다음 강좌로...](../5강%20-%20배열/강의자료.md)


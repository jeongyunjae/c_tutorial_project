# 포인터

## 목차
[1. 서론](#서론)  
[2. 포인터](#포인터)   
[3. 연산자](#연산자)   
[4. 포인터와 함수](#포인터와-함수)   
[5. 배열과 포인터](#배열과-포인터)   
[6. 포인터 배열](#포인터-배열)   
[7. 문자열과 포인터](#문자열과-포인터)   
[8. 동적 메모리 할당](#동적-메모리-할당)   

## 서론
C 언어의 특징 중 하나는 명시적으로 포인터를 사용할 수 있습니다.

명시적으로 포인터를 사용하면 메모리 주소를 직접 접근하고 사용할 수 있습니다.

메모리에 접근할 수 있으면 어떤 일들을 할 수 있을가요?

## 주소
선언한 변수들의 데이터는 메모리에 저장됩니다.  

컴퓨터는 데이터를 불러오기 위해 메모리의 위치가 필요한데 이를 주소라고 합니다.

## 포인터

주소를 다루기 위한 자료형을 `포인터`라고 합나다.

`포인터 변수`는 메모리 상에 위치한 데이터의 주소값을 저장할 수 있습니다.

`포인터`는 사용하던 자료형 뒤에 `*` 연산자와 함께 쓰는 것으로 자료형에 맞는 `포인터 변수`를 선언할 수 있습니다.


> 포인터 변수 선언 방법
```c
int *p;         // int형 포인터 변수 p를 선언합니다.
float *a, b;    // float형 포인터 변수 a 와 float형 변수 b를 선언합니다.
char *a, *b;     // char형 포인터 변수 a 와 b 를 선언합니다.
```


## & 연산자

메모리의 주소를 알려주는 연산자

> & 연산자 예
```c
int value  = 100;
int *ptr = &value;
printf("value = %d\n", value);
printf("&value = %p\n", &value);
printf("ptr    = %p\n", ptr);
printf("&ptr = %p\n", &ptr);
printf("%d", &i);
```

**예제 결과**
```c
value = 100
&value = 0x7ffd3cf1aa54
ptr = 0x7ffd3cf1aa54
&ptr = 0x7ffd3cf1aa58

// 값은 변수가 들어가는 메모리 번지가 달라져 실행할때마다 달라질 수 있습니다.
// value 의 주소값과 ptr 의 값이 같은 것을 볼 수 있습니다.
// ptr 은 value 의 주소값을 갖고 있습니다.
```


## * 연산자

포인터 변수로 주소를 가리키고 있다고 해서 무엇을 할 수 있을까요?

주소만 가지고 있고 조작을 할 수 없다면 할 수 있는 건 많지 않을 것입니다.

`*` 연산자는 포인터가 가리키는 메모리의 공간에 접근하는 연산자입니다.

`*` 연산자를 이용해서 값을 읽어오고 변경할 수 있습니다.

> * 연산자 예
```c
int i = 100;
int *p = &i;
printf("%d", *p);
*p = 200;
printf("%d", *p);
printf("%d", i);
```

**예제 결과**
```c
100
200
200

// *p 를 통해 메모리 공간에 100이 저장되어 있는 것을 확인했습니다.
// *p 의 값을 변경해서 메모리 공간에 저장된 값이 바뀌고 i의 값도 바뀐 것을 확인할 수 있습니다.
```


## 포인터 변수의 크기
포인터 변수가 담는 것은 메모리의 주소입니다.

메모리의 주소는 자료형과 상관없이 8바이트로 표현할 수 있습니다.

따라서 포인터 변수는 항상 8바이트로 크기가 동일합니다.

```c
    int b;
    int *p = &b;
    double a;
    double *u = &a;
    printf("%d %d",sizeof(p), sizeof(u));
```

**프로그램 결과**
```c
8 8

// int 형이나 double 형이나 주소값은 8로 동일한 것을 확인했습니다.
```


## 포인터와 함수

`*` 연산자를 이용해 메모리 주소에 있는 값을 변경해보았지만 값을 변경하는 것은 포인터 변수가 아니어도 가능합니다.

그렇다면 굳이 포인터를 이용해 변경할 필요가 없어보이지만 포인터가 필요한 이유가 있습니다.

포인터가 필요한 이유    

- C 프로그램에서 함수에 변수를 넘기면 기본적으로 변수 자체가 아닌 값만 복사해서 넘겨줍니다. (값에 의한 호출)

- 함수에서 변수의 값이 바뀌어 저장할 필요가 있을 때 포인터를 통해 넘겨줄 수 있습니다. (참조에 의한 호출)

- 반환 값이 여러 개인 경우에도 참조에 의한 호출로 해결할 수 있습니다.

## 값에 의한 호출

```c
void swap(int a, int b);
int main()
{
    int a = 1, b = 2;
    swap(a,b);
    printf("main - a : %d  b : %d", a,b);
    return 0;
}

void swap(int a, int b)
{
    int temp;

    temp = a;
    a = b;
    b = temp;

    printf("swap -  a : %d  b : %d ", a,b);
}
```
---
**프로그램 결과**
```c
    swap - a : 2   b : 1
    main - a : 1   b : 2

    // 값이 바뀌지 않았습니다.
```

swap 함수 내에서는 a와 b의 값이 바뀌었지만
main 함수 내에서는 a와 b의 값이 바뀌지 않은 것을 볼 수 있습니다.



## 참조에 의한 호출

* 참조에 의한 호출 방법  

```c
void swap(int * a, int * b);            // 매개 변수를 포인터 형으로 선언합니다.
int main()
{
    int a = 1, b = 2;
    swap(&a,&b);                        // 함수의 주소를 인자로 전달합니다.
    printf("main - a : %d  b : %d", a,b);
    return 0;
}

void swap(int *a, int *b)
{
    int temp;

    temp = *a;                          // * 연산자를 이용해 값을 사용합니다.
    *a = *b;
    *b = temp;

    printf("swap -  a : %d  b : %d ", a,b);
}
```
---
**프로그램 결과**
```c
    swap - a : 2   b : 1
    main - a : 2   b : 1

    // main 함수의 변수 a와 변수 b의 값이 바뀐 것을 볼 수 있습니다.
```

## 배열과 포인터
배열은 특정 자료형을 메모리 상에서 연속해서 저장한 형태입니다.

이와 같은 특성 때문에 포인터 연산을 이용해 배열을 효율적으로 다룰 수 있습니다.

배열 이름으로 참조 연산을 하면 배열의 첫번째 원소의 주소값이 나옵니다.

배열의 원소들도 포인터 연산을 통해 접근할 수 있습니다.

> 예  
```c
    int a[100] = {0};
    int *p = a;             // p = &a[0]

    printf(" p의 값은 %d\n" , *p);

    p = a + 1;              // p[1] 접근
    *p = 10;                
    *(a+2) = 20;            // 배열 이름으로도 포인터 연산 가능합니다.
    *(p + 2) = 30;          // p[1 + 2] 즉 p[3]에 접근합니다.

    printf(" p[1] = %d, p[2] = %d, p[3] = %d", p[1], p[2], p[3]);
```
---
**프로그램 결과**
```c
    p의 값은 0
    p[1] = 10, p[2] = 20, p[3] = 30
```

## 2차원 배열과 포인터
2차원 배열의 인덱스를 하나 제거하면 포인터가 됩니다.

```c
int b[i][j]
b[a] == &b[a][0]
b[a]+c == &b[a][c]
```

2차원 배열의 인덱스를 두 개 제거하면 포인터가 됩니다.

```c
int b[i][j]
b == b[j] 크기의 배열을 가르키는 포인터
b + a == &b[a][0]
```

포인터를 이용한 b[a][c]의 표기 방법
```c
*(b[a] + c)
*(*(b + a) + c)
(*(b + a))[c]
```

## 배열 포인터
배열 포인터란 배열을 가리킬 수 있는 포인터를 의미합니다.

> 배열 포인터 예
```c
int main{
int arr[2][3] = {{10, 20, 30},{40, 50, 60}};
int (*pArr)[3] = arr;

printf("%d\n", arr[1][1]);  
printf("%d\n", pArr[1][1]);
return 0;
}
```
---
**프로그램 결과**
```c
    50 50
```



## 포인터 배열
포인터 배열이란 배열 요소로 포인터 변수를 가지는 배열을 의미합니다.

> 포인터 배열 예
```c
int a = 1, b = 2, c = 3;
int* arr[3] = {&a, &b, &c};

for (int i = 0; i < arr_len; i++){
    printf("%d  ", *arr[i]);
}  
```
---
**프로그램 결과**
```c
1 2 3
```

## 문자열과 포인터
문자열 배열은 큰 따옴표를 통해 문자열을 넣을 수 있습니다.

문자열 배열은 문자열을 변경할 수 없어서 문자열 상수라고도 합니다.

```c
char str[] = "C Github"
```

문자열 포인터는 문자열을 변경할 수 있습니다.

```c
char *p = "C Github"
*p = 'D'
printf("%s", p);
```

---
**프로그램 결과**
```c
    D Github
```

*주의 !*

C++ 11 이후에는 char * 에 문자열 상수를 바로 넣는 게 권장되지 않습니다.  
위의 프로그램처럼 문자를 바꾸지 않는다면 앞에 const를 추가한 const char * 을 사용해 주세요.




## 동적 메모리 할당
C언어에서 `포인터`를 사용하는 중요한 이유 중 하나는 동적 메모리 할당 입니다.

배열은 변수를 선언하면서 크기가 정해집니다.

데이터를 처리할 때 배열은 사용할 수도 있는 최대의 크기로 배열의 크기를 잡아야합니다.

이렇게 되면 평소에는 배열의 공간이 10개 이내로 사용되는데 특정 경우에 따라 10000개가 필요하다면 10000개로 잡아야 합니다.

이처럼 크기가 정해져있지 않을 때 정해진 크기가 아니라 들어온 값에 따라 배열의 크기를 정할 수 있다면 메모리를 절약할 수 있습니다.

정해지지 않은 크기를 사용시에 정해서 할당하는 방법을 `동적 메모리 할당`이라고 합니다.

동적으로 메모리를 할당하게 되면 메모리 영역 중 `Heap` 공간에 저장이 되는데 주소가 어디가 될지 모릅니다.

그렇기 때문에 포인터를 통해 주소를 할당했으면 어디인지 주소를 갖고 있어야합니다.


* 동적 메모리 할당 방법
```c
malloc(바이트 크기)
calloc(데이터 개수, 자료형 크기)

// 사용 이후
free()
```

> 동적 메모리 할당 예제
```c
int *iptr = (int *)malloc(sizeof(int) * 100);
// int iptr[100]과 같은 크기를 할당합니다;


double *dptr = (double *)calloc(100,sizeof(dobule));
// double dptr[100]과 같은 크기를 할당합니다.
```

사용 이후에 free()를 사용하지 않거나 포인터로 다른 주소를 참조하게 되면 메모리는 할당되있지만 사용하지 않아 메모리의 누수가 일어납니다.

작은 크기의 프로그램일 때는 문제가 생기지 않지만 큰 프로그램을 작성할 때 누수가 계속 발생하면 메모리가 부족해져 프로그램이 종료될 수 있습니다.

### 다음 단계
- [실습문제로...](./실습문제.md)
- [다음 강좌로...](../7강%20-%20사용자%20정의형/강의자료.md)
